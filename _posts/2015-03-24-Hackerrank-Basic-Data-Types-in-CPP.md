---
layout: post
title: 'Hackerrank - Basic Data Types'
published: true
---
#### מתוך Hackerrank - Basic Data Types (cpp)

בתרגיל הזה, אנחנו מתבקשים לעשות משהו מאוד פשוט -לקלוט קלט של כל מיני נתונים מסוגים סטנדרטים שונים ש בcpp ולהדפיס אותם.

אפשר לגשת לבעיה בשתי צורות - האחת, לקלוט כל נתון למשתנה מסוג הנתונים המתאים ולאחר מכן להדפיס הכל לפי הדרישות, והשנייה היא לקלוט את כל הסיפור הזה כמחרוזת, ופשוט להדפיס אותה.

יש שיקראו לדרך השנייה מתחכמת ולראשונה נאיבית, אציג את שתיהן, ואולי אנסה לקבוע איזו עדיפה.

שנתחיל? 
הדרך הראשונה תראה כך:
<div dir="ltr">
{% highlight cpp %}
#include <iostream>

int main()
{
    int i;
    long l; 
    long long ll;
    char c; 
    float f;
    double d;    
    scanf("%d %ld %lld %c %f %lf  ", &i,&l,&ll,&c,&f,&d);
    printf("%d\n%ld\n%lld\n%c\n%f\n%lf",i,l,ll,c,f,d);
    return 0;
}
{% endhighlight %}
</div>
נראה קצת מסורבל, נאיבי. מצד שני, סביר להניח שזו הייתה הפואנטה של התרגיל, להכיר קצת את סוגי המשתנים המקובלים ב cpp.
אפשר לציין עכשיו, שבניגוד לשיטה השנייה, שאראה מייד,  השיטה הזאת תהיה מאוד "רגישה" להקלדת הנתונים בסדר הלא נכון.

שנראה את השיטה השנייה? 
<div dir="rtl">
{% highlight cpp %}
#include <iostream>

int main()
{
    string s;
    for(int i=0; i<6; i++){
	cin>>s;
	cout<<s<<endl
}
{% endhighlight %}
</div>

ניתן לראות כאן שימוש במנגנוני הקלט\פלט "החדשים" לעומת שפת C. קלטנו את הערכים שהמשתמש הקליד אחד אחרי השני, כל פעם אל תוך s, בתור מחרוזת, ואחר כך פשוט פלטנו אותם בתור מחרוזת.
כך נמענו מכל ניהול כלשהו של סוגי הנתנוים ב-CPP (ואולי חבל שכך). עוד בעיה - המערכת לא רגישה כלל לטעויות בקלט - וכך היא לא תתריע בפני שגיאה ותפעל גם במקרים בהם היא לא אמורה לעשות כך.
למי שלא כ"כ מתמצא במנגנוני הקלט החדשים של CPP, cin>>s ניגש לקלט הסטנדרטי ומכניס את הקלט ל s. cout<<s<<endl פולט את s לקלט הסטנדרטי, כשתפקיד endl הוא למעשה "סוף שורה".
על כך - אולי בפוסט אחר.

על כל טעות מכל סוג שהיא שנפלה, כל שאלה - אתם מוזמנים "לדווח" בתגובות ;)
